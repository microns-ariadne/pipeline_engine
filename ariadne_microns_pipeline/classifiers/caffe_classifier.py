import luigi
import numpy as np
import rh_logger
import os

"""The environment variable that stores the GPU #"""
MICRONS_IPC_WORKER_GPU = "MICRONS_IPC_WORKER_GPU"

from ..targets.classifier_target import AbstractPixelClassifier
from ..algorithms.normalize import NormalizeMethod, normalize_image

class CaffeClassifier(AbstractPixelClassifier):
    
    network_map = {}
    
    def __init__(self, model_path, proto_path, class_names, 
                 normalize_method,
                 xpad=0, ypad=0, zpad=0,
                 saturation_level=0.05, offset=.5):
        '''Initializer
        
        :param model_path: path to the Caffe model file
        :param proto_path: path to the Caffe prototxt file
        :param class_names: a list of the names for the class probability maps
        generated by this classifier
        :param normalize_method: one of the methods from the NormalizeMethod
        enumeration - EQUALIZE_ADAPTHIST for an adaptive histogram over the
        image, RESCALE for a uniform rescaling, discarding outliers or NONE
        for no normalization
        :param xpad: the amount of padding needed on each side in the X 
        direction
        :param ypad: the amount of padding needed on each side in the Y
        direction
        :param zpad: the amount of padding needed on each side in the Z
        direction
        :param saturation_level: the fraction of outliers to discard from
        the top and bottom of the distribution for the RESCALE normalization
        method
        :param offset: the offset to subtract from the normalization result
        for the RESCALE and EQUALIZE_ADAPTHIST methods.
        
        If no padding is requested, then the zero_pad_source_data flag is
        set going into PyGreentea and the image is padded with zeros if
        necessary.
        '''
        self.model_path = model_path
        self.proto_path = proto_path
        self.class_names = class_names
        self.normalize_method = normalize_method
        self.xpad = xpad
        self.ypad = ypad
        self.zpad = zpad
        self.saturation_level = saturation_level
        self.offset = offset
    
    def __getstate__(self):
        return dict(model_path=self.model_path,
                    proto_path=self.proto_path,
                    class_names=self.class_names,
                    normalize_method=self.normalize_method.name,
                    xpad=self.xpad,
                    ypad=self.ypad,
                    zpad=self.zpad,
                    saturation_level=self.saturation_level,
                    offset=self.offset)
    
    def __setstate__(self, state):
        self.model_path = state["model_path"]
        self.proto_path = state["proto_path"]
        self.class_names = state["class_names"]
        self.normalize_method = NormalizeMethod[state["normalize_method"]]
        self.xpad = state["xpad"]
        self.ypad = state["ypad"]
        self.zpad = state["zpad"]
        self.saturation_level = state["saturation_level"]
        self.offset = state["offset"]
    
    def classify(self, image, x, y, z):
        import PyGreentea

        if len(self.network_map) == 0:
            device_id = int(os.environ.get(MICRONS_IPC_WORKER_GPU, "0"))
            PyGreentea.caffe.set_device(device_id)
            PyGreentea.caffe.set_mode_gpu()
        key = (self.model_path, self.proto_path)
        if key not in self.network_map:
            net = PyGreentea.caffe.Net(self.proto_path,
                                       self.model_path,
                                       PyGreentea.caffe.TEST)
            self.network_map[key] = net
        else:
            net = self.network_map[key]
        if self.xpad == 0 and self.ypad == 0 and self.zpad == 0:
            zero_pad_source_data = True
        else:
            zero_pad_source_data = False
        image = normalize_image(image, self.normalize_method, 
                               saturation_level=self.saturation_level,
                              offset=self.offset)
        dataset = [dict(name="Volume-%d-%d-%d" % (x, y, z),
                        data=image[np.newaxis, :])]
        output = PyGreentea.process(
            net, dataset,
            zero_pad_source_data=zero_pad_source_data)[0]
        result = dict(
            [(k, (o[self.zpad:o.shape[0] - self.zpad,
                    self.ypad:o.shape[1] - self.ypad,
                    self.xpad:o.shape[2] - self.xpad] * 255).astype(np.uint8))
             for k, o in zip(self.class_names, output)])
        return result
    
    def get_x_pad(self):
        return self.xpad
    
    def get_y_pad(self):
        return self.ypad
    
    def get_z_pad(self):
        return self.zpad
    
    def get_class_names(self):
        return self.class_names
    
    def run_via_ipc(self):
        return True
        

